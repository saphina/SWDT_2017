#include <math.h>
#include "fft.h"

#define M_PI (3.1415926535897932384626433832795)

bool Get_Freq_Amp(ShortComplex *arr, double *freq, double *amp, int N)
{
	//Ёто комплексные числа, результат пр€мого дискретного преобразовани€ ‘урье
    //ShortComplex - это структура с пол€ми: double re, im;
	
    //это индекс комплексного числа в массиве arr
    int i = N-1;

    //это частота дискретизации
    double nSamplesPerSec = 44100.0;

    //убираем зеркальный эффект, просто отбрасыва€ вторую половину
    int Nmax = (N + 1) / 2; 

    //мы хотим получить массив гармоник.
    //это массив амплитуд, массив частот и массив фаз дл€ каждой гармоники
    //freq= new double[Nmax];
    //amp= new double[Nmax];
	
    //это индекс гармоники. в конце алгоритма он будет равен количеству 
	//найденных гармоник
    int j = 0;

    //это нижний предел амплитуды гармоники. тут может быть число больше нул€
    //в зависимости от того, какие амплитуды мы считаем ничтожно малыми.
    double limit = 0.001;
    
    //вспомогательна€ переменна€ дл€ оптимизации
    double abs2min = limit  *limit  *N  *N;
	
    //получаем посто€нную составл€ющую
    if (arr[i].re >= limit)
    {
        amp[j] = arr[i].re / N;
		freq[j] = 0.0;
		++j;
    }
    ++i;
    //получаем остальные гармоники
    for(i = 1; i < Nmax; ++i)
    {
        double re = arr[i].re;
        double im = arr[i].im;
		
        //это квадрат модул€ комплексного числа arr[i]
		double abs2 = re  *re + im  *im;
		
        //отбрасываем слишком слабые гармоники
        if (abs2 < abs2min)
            continue;

		//вычисл€ем апмлитуду. 2.0 - дл€ устранени€ зеркального эффекта
		amp[j] = 2.0  *sqrt(abs2) / N;
		//получаем частоту
		freq[j] = (nSamplesPerSec  *i) / N;
		
        ++j;
    }
	return true;
}
