#include <math.h>

#include "fft.h"
#define nSamplesPerSec 44100.0

/* Данная функция производит обработку результатов вычисления функции
БПФ. Функция в качестве аргументов принимает указатель на массив
данных из БПФ, указатель на массив частот, указатель на массив амплитуд
и количество отсчетов (samples). */
bool Get_Freq_Amp(ShortComplex *arr, double *freq, double *amp, int N)
{
    //Это комплексные числа, результат прямого дискретного преобразования Фурье
    //ShortComplex - это структура с полями: double re, im;
    //это индекс комплексного числа в массиве arr
    int i = N - 1;
    //это частота дискретизации
    //double nSamplesPerSec = 44100.0;
    //убираем зеркальный эффект, просто отбрасывая вторую половину
    int Nmax = (N + 1) / 2; 
    //мы хотим получить массив гармоник.
    //это массив амплитуд, массив частот и массив фаз для каждой гармоники
    //freq= new double[Nmax];
    //amp= new double[Nmax];
    
    //это индекс гармоники. в конце алгоритма он будет равен количеству 
    //найденных гармоник
    int j = 0;
    
    //это нижний предел амплитуды гармоники. тут может быть число больше нуля
    //в зависимости от того, какие амплитуды мы считаем ничтожно малыми.
    double limit = 0.001;
    
    //вспомогательная переменная для оптимизации
    double abs2min = pow(limit, 2) * N * N;
    
    //получаем постоянную составляющую
    if (arr[i].re >= limit)
    {
        amp[j] = arr[i].re / N;
        freq[j] = 0.0;
        ++j;
    }
    //получаем остальные гармоники
    for(i = 1; i < Nmax; ++i)
    {
        double re = arr[i].re;
        double im = arr[i].im;
        //это квадрат модуля комплексного числа arr[i]
        double abs2 = re  *re + im  *im;
        //отбрасываем слишком слабые гармоники
        if (abs2 < abs2min)
            continue;
        //вычисляем апмлитуду. 2.0 - для устранения зеркального эффекта
        amp[j] = 2.0  *sqrt(abs2) / N;
        //получаем частоту
        freq[j] = (nSamplesPerSec  *i) / N;
        ++j;
    }
    return true;
}
